# pong-base

Coordinate client and server firebase use with shared code and easy server-side behavior.

## installation

```bash
$ npm install [THIS REPO URL]
```

## overview

There are several parts to pongbase that you use together to streamline firebase use on both the client and server.

* `$model`.  You'll create services that are used by both the angular client and server to refer to a specific part of the data.
* `$modelManager`.  Server-side pongular services give you an easy way to write back-end behavior that must be secure.
* `model` directive.  Use this in your angular client wherever you need to retreive data.

## shared code

Shared code uses a bit of hackery to choose the right DI library.  This is the snippet that I add to the top of all my `.shared` files:

```
# shared by browser and node
di = (typeof window!='undefined') && window.angular || require('pongular').pongular
di.module 'appApp'
```

On the client, that will use angular's DI, and on the server, it will use pongular's.  The syntax for both is identical.  Magic!

## Details

### shared: $model

Define `$model`s in your `.shared` code to get:

* use firebase without controller code with the `model` directive
* consistent references to FB paths on both client and server
* extra syntactic sugar on the client and server for directly modifying FB resources.

```
# defined somewhere else...
# .service 'fbRoot', -> new Firebase("MY_FIREBASE_URL")

.service 'Profile', ($model, fbRoot)->
  $model fbRoot.child('profile')

.service 'Site', ($model, fbRoot)
  $model fbRoot.child('site')

.service 'Objective', ($model, fbRoot)
  $model fbRoot.child('objective')

.service 'ObjectiveAssigned', ($model, fbRoot)
  $model fbRoot.child('objectiveAssigned')

.service 'Project', ($model, fbRoot)->
  $model fbRoot.child('project')

.service 'ProjectMember', ($model, fbRoot)->
  $model fbRoot.child('projectMember')
```

You can directly use these services anywhere in your client or server by simply injecting them:

```
# in angular-land
# everything returns a firebase
.directive 'newProjectForm', ['Project', (Project)->
  template: ...
  link: (scope,el,attrs)->
    scope.create = (data)-> Project.add(data)
]

# in pongular-land
# everything returns a promise wrapping the firebase js library
.service 'setName', ['Site', (Site)->
  (name)->
    # gets a child with the key of 'SINGLE'
    Site.single()

    .update( {name: name} )

]
```
### client: model directive

The `model` directive lets you easily use services defined with `$model` in your angular app.

No need to attach a variable to a controller "by hand" or anything like that.  You just specify a `model` attribute:

```
<div model='Site'>
  {{Site.name}}
</div>
```

Specifying nothing but `model` will tell the directive to treat it like a singleton.  It will create an isolate scope with a Site property.  That property is bound to the .single() method of the Site service, which resolves to a child with the key of 'SINGLE'

Once you start specifying anything else but the model, the directive will get clever about what it thinks you want
and build the firebase query accordingly.

#### queries generated by model attributes

There are three possible attributes you can use along with the `model` attribute:

* `by` will filter your records based on one of their properties, using firebase's `orderByChild()`.
* `with` can be used with or without `by`.  In conjunction with `by`, it will use firebase's `equalTo()` to limit the `orderByChild()`.  Without `by`, it simply gets the record with the matching key.  If `with` is set to an array of items, it is assumed to be a composite key and is `join()`d with `|`.
* `limit` will simply apply a `limitToFirst()` filter on the firebase query.  If no `limit` is specified, it defaults to one.
* if none of these attributes are specified, the query will get the child at 'SINGLE' as a singleton.

#### model attribute examples

Specify a limit and the directive will behave like `ng-repeat` and copy the contents for each record in the collection.  It will apply orderByPriority() to the query automatically.

```
<div model='Profile' limit='10'>
  <h1>{{Profile.name}}</h1>
</div>
```

This would create an `<h1>` element for each Profile, showing the name field.

You can take use the `by` and `equal-to` attributes to take advantage of firebase's orderByChild query filter in order to select a subset of children from Firebase:

```
<div model='Profile' by='is_public' with='true' limit='10'>
  <h1>{{Profile.name}}</h1>
</div>
```

You can nest `model` directives in lots of interesting ways.

Nest your `model`s to show data from multiple objects.  Here, we're showing stuff from the Site singleton as well as the Profile found with a `uid` matching `auth.uid`.  

```
<div model='Site'>
  <div model='Profile' by='uid' with='{{auth.uid}}' limit='1'>
    <h1>{{profile.name}}</h1>
    <h2>Karma: {{profile.karma_earned}}</h2>
    <span>Total karma for all users on site: {{site.karma_earned_total}}</span>
  </div>
</div>
```

Here's how to nest `model`s to reflect a many-to-many relationship.
This shows the projects that the user is a member of.

```
<div model='Profile' by='uid' with='{{auth.uid}}' limit='1'>
  <h1>{{Profile.name}}</h1>

  <h3>My Projects</h3>

  <div model='ProjectMember' by='profile_key' with='Profile.$key'>
    <div model='Project' with='ProjectMember.project_key'>
      <h4>{{Project.name}}</h4>
      <span>Member since {{ProjectMember.created_on}}</span>
  </div>
</div>
```

In this case:

* We repeat the innards of the ProjectMember div for each ProjectMember that has a profile_key equal to the current Profile.$key.
* For each ProjectMember, we find the Project `model` with a matching project_key.


Show a logged in user's profile (found with auth.uid scope variable) and outstanding objectives and projects they're members of.
```
<div model='Site'>
  <div model='Profile' by='uid' with='{{auth.uid}}' limit='1'>
    <h1>{{profile.name}}</h1>
    <h2>Karma: {{profile.karma_earned}}</h2>
    <span>Total karma on site: {{site.karma_earned_total}}</span>

    <h3>My Objectives</h3>

    <div model='ObjectiveAssignment' by='profile_complete' with='[profile.$key,false]'>
      {{objectiveAssignment.name}}: {{objectiveAssignment.karma_reward}} karma
    </div>

    <h3>My Projects</h3>

    <div model='ProjectMember' by='profile_key' with='profile.$key'>
      <div model='Project' key='projectMember.project_key'>
        <h4>{{project.name}}</h4>
        <span>Member since {{projectMember.created_on}}</span>
    </div>
  </div>
</div>
```

### server: $modelManager

Define `$modelManager`s in your server code and call `listen()` when you start your server:

```
# this is called somewhere in server startup.
.service 'CalledByMyServer', (ProfileManager, ObjectiveAssignedManager)->
  ->
    for m in (ProfileManager, ObjectiveAssignedManager)
      m.listen()

.service 'ProfileManager', ($modelManager, Site, Profile, ImportantServerSideFunction)->
  $modelManager Profile,
    # automatically adds created_on and modified_on fields
    timestamp: true

    # will only get run once and set an is_initalized flag
    initialize: (rec)->
      ImportantServerSideFunction(rec)

    # counters will update targets based on add/removes on model
    counters:

      # just specify a target and it will count every record
      # count is saved to in a 'profileCount' field
      profile_count: 
        target: Site.single()

      # specify a countIf to selectively increment or decrement
      # site.profileConfirmedCount will inc or dec not just add/removes
      # but also changes to the field (changes tracked by is_confirmed_old)
      profile_confirmed_count:
        countIf: ['is_confirmed', true]
        target: Site.single()

      # specify a field to total and it will inc or dec by that amount
      # changes tracked by karma_old
      karma_earned_total:
        total: 'karma_earned'
        target: Site.single()

.service 'ProjectMemberManager', ($modelManager, ProjectMember, Project)->
  $modelManager ProjectMember,
    counters:

      # provide a function as your counter target and whatever it returns will be used as the target
      project_member_count:
        target: (rec)-> Project.byKey(rec.profile_key)

.service 'ObjectiveAssignedManager', ($modelManager, ObjectiveAssigned, Profile, Objective)->
  $modelManager ObjectiveAssigned,

    # composite indexes allow for easy queries on multiple children
    composites:

      # will create a field 'profile_completed_key' on each child
      # it will be always updated to "#{profile_key}|#{is_completed}"
      profile_complete: ['profile_key', 'is_complete']
      objective_complete: ['objective_key', 'is_complete']

    counters:

      # if the function you provide returns an array, it will update the counter in each target
      objective_assigned_count:
        target: (rec)-> [Site.single(), Profile.byKey(rec.profile_key), Objective.byKey(rec.objective_key)]

      objective_assigned_complete_count:
        countIf: ['is_complete', true]
        target: (rec)-> [Site.single(), Profile.byKey(rec.profile_key), Objective.byKey(rec.objective_key)]

      # using countIf, total, and target to keep a running total of karma earned for a profile
      # note that this also triggers the Profile counter that totals the earned_karma field
      karma_earned:
        countIf: ['is_complete', true]
        total: 'karma_reward'
        target: (rec)-> Profile.byKey(rec.profile_key)

```

## build notes

Shared code needs to be deployed in both places.  I personally just modify my build tasks to look for `*.shared.coffee` files and deal with them appropriately.

Whatever build process you use, make sure that your `.shared` code ends up in both your client and server distribution.

#### angular-fullstack

update your ```Gruntfile.js``` to make sure shared code ends up in the same place in your ```dist/```.

```
    // Copies remaining files to places other tasks can use
    copy: {
      dist: {
        files: [{
          expand: true,
          dot: true,
          cwd: '<%= yeoman.client %>',
          dest: '<%= yeoman.dist %>/public',
          src: [
            '*.{ico,png,txt}',
            '.htaccess',
            'bower_components/**/*',
            'assets/images/{,*/}*.{webp}',
            'assets/fonts/**/*',
            'index.html'
          ]
        }, {
          expand: true,
          cwd: '.tmp/images',
          dest: '<%= yeoman.dist %>/public/assets/images',
          src: ['generated/*']
        }, {
          expand: true,
          dest: '<%= yeoman.dist %>',
          src: [
            'package.json',
            'client/app/**/*.shared.coffee', // ADD FOR SHARED MODULES ON CLIENT!
            'server/**/*'
          ]
        }]
      },
```